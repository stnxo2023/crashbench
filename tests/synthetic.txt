synthetic1.c	Integer Overflow	At Line 8, count * sizeof(Item) can overflow if count is very large. This leads malloc to allocate a tiny buffer, but the subsequent for loop will write to the full count, causing a heap buffer overflow.
synthetic2.c	Incorrect sizeof	At Line 8, sizeof(user) returns the size of the pointer (usually 4 or 8 bytes), not the size of the User struct. This allocates far too little memory, leading to an immediate overflow when members are accessed.
synthetic3.c	Signed/Unsigned Mismatch	At Line 8, len is a signed int. If a negative value is passed, the check len > MAX_SIZE passes (because a negative is less than 256), but memcpy treats it as a large unsigned size_t, causing a massive buffer overflow.
synthetic4.c	Off-by-one Error	At Line 9, strncat's third argument is the remaining space, not the total size. By using sizeof(path) - strlen(path), there is no room left for the null terminator if the string is exactly full, leading to a 1-byte overflow.
synthetic5.c	Use-After-Free	At Line 10, current is freed. Immediately after, current->next is accessed to update the loop. Since the memory for current is already returned to the heap, this is a classic use-after-free.
synthetic6.c	Format String Attack	At Line 7, printf(buffer) is called without a format specifier like %s. If the user controls the msg (and thus the buffer), they can input %p or %n to leak stack data or write to arbitrary memory.
synthetic7.c	Dangling Pointer	At Line 8, the function returns status_string, which is an array allocated on the stack. Once the function returns, that memory is invalidated. The caller will be pointing to "garbage" memory.
synthetic8.c	Double Free Risk	At Line 7, if realloc fails, it returns NULL but the original ptr is not freed. However, this code manually calls free(ptr). If the caller also tries to free the pointer upon receiving NULL, it results in a double free.
synthetic9.c	Uninitialized Variable	At Line 11, if both is_admin and has_token are false, access_level is never initialized. It will contain whatever "junk" value was on the stack, potentially leading to unauthorized access.
synthetic10.c	Missing Null Terminator	At Line 8, strncpy does not null-terminate the destination if the source is longer than the limit. printf will then continue reading past the 16-byte buffer until it happens to hit a null byte elsewhere in memory.
